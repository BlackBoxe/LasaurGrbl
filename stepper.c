/*
  stepper.c - stepper motor driver
  Processes block from the queue generated by the planer and pulses
  steppers accordingly via a dynamically adapted timer interrupt.
  Part of LasaurGrbl

  Copyright (c) 2011 Stefan Hechenberger
  Copyright (c) 2009-2011 Simen Svale Skogsrud
  Copyright (c) 2011 Sungeun K. Jeon
  Copyright (c) 2011 Arthur Wolf
  
  Inspired by the 'RepRap cartesian firmware' by Zack Smith and 
  Philipp Tiefenbacher.

  LasaurGrbl is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  LasaurGrbl is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
  ---
  
  Some Notes about setting up interrupts:
  The LPC1768 has 4 timers which are clocked at 1/4 the system clock. This
  means the timer ticks per microsecond is 24 ()(SystemCoreClock/4 )/1000000).
  The following registers are of relevance.
  LPC_SC->PCONP |= (1 << 1);  // power up TIMER0, default
  LPC_TIM0->TCR = 0x2;        // timer mode, default
  LPC_TIM0->CTCR = 0x0;       // timer mode, default
  LPC_TIM0->PR = 0;           // prescaler, default
  LPC_TIM0->MR0 = ticks;      // when to trigger
  LPC_TIM0->MCR |= 1 << 0;    // interrupt on match
  LPC_TIM0->MCR |= 1 << 1;    // reset on match
  LPC_TIM0->TCR = 1;          // enable counter
  LPC_TIM0->TCR = 0;          // disable counter
  
  NVIC_SetVector(TIMER0_IRQn, (uint32_t)&isr_handler);
  NVIC_EnableIRQ(TIMER0_IRQn);
  
  In the isr handler function the IR register needs to be reset at the very top
  LPC_TIM0->IR = 0x1<<1;
  
  also see: p492 of the lpc17xx manual
*/

#include <inttypes.h>
#include "stepper.h"
#include "config.h"
#include "planner.h"
#include "limits.h"
#include "more_control.h"
#include "serial.h"


#define CYCLES_PER_MICROSECOND ((SystemCoreClock/4 )/1000000)  //96000000/4/1000000 = 24
#define CYCLES_PER_ACCELERATION_TICK ((SystemCoreClock/4)/ACCELERATION_TICKS_PER_SECOND)  // 24MHz/100 = 240000


DigitalOut led2(LED2);

// real-time position in absolute steps
static int32_t st_position[3]; 

static block_t *current_block;  // A pointer to the block currently being traced

// Variables used by The Stepper Driver Interrupt
static uint32_t out_bits;       // The next stepping-bits to be output
static int32_t counter_x,       // Counter variables for the bresenham line tracer
               counter_y,
               counter_z;
static uint32_t step_events_completed; // The number of step events executed in the current block

// Variables used by the trapezoid generation
static uint32_t cycles_per_step_event;        // The number of machine cycles between each step event
static uint32_t acceleration_tick_counter;    // The cycles since last acceleration_tick.
                                              // Used to generate ticks at a steady pace without allocating a separate timer.
static uint32_t adjusted_rate;       // The current rate of step_events according to the speed profile
static bool cycle_start;             // Cycle start flag to indicate program start and block processing.

//         __________________________
//        /|                        |\     _________________         ^
//       / |                        | \   /|               |\        |
//      /  |                        |  \ / |               | \       s
//     /   |                        |   |  |               |  \      p
//    /    |                        |   |  |               |   \     e
//   +-----+------------------------+---+--+---------------+----+    e
//   |               BLOCK 1            |      BLOCK 2          |    d
//
//                           time ----->
//
//  The speed profile starts at block->initial_rate, accelerates by block->rate_delta
//  during the first block->accelerate_until step_events_completed, then keeps going at constant speed until
//  step_events_completed reaches block->decelerate_after after which it decelerates until final_rate is reached.
//  The slope of acceleration is always +/- block->rate_delta and is applied at a constant rate following the midpoint rule.
//  Speed adjustments are made ACCELERATION_TICKS_PER_SECOND times per second.

static void adjust_speed( uint32_t steps_per_minute );
void st_pulse_handler();



// Initialize and start the stepper motor subsystem
void st_init() {
  clear_vector(st_position);
  acceleration_tick_counter = 0;

  // define step and dir pins as outputs
  STEPPING_PORT->FIODIR |= (STEP_MASK | DIRECTION_MASK);
  
  // prime with invert_mask
  STEPPING_PORT->FIOSET =  settings.invert_mask & (STEP_MASK | DIRECTION_MASK);
  STEPPING_PORT->FIOCLR = ~settings.invert_mask & (STEP_MASK | DIRECTION_MASK);
  
  // initiate timer for stepper interrupt
  // set (MR0) and reset (MR1) is done by the same interrupt
  LPC_TIM0->MR0 = CYCLES_PER_MICROSECOND * 100 - 1;  //100-20000mm/min => 18182-91us  @32.81 steps/mm
  LPC_TIM0->MR1 = CYCLES_PER_MICROSECOND * settings.pulse_microseconds -1;
  LPC_TIM0->MCR = 11; // for MR0 and MR1, with no reset at MR1
    
  NVIC_SetVector(TIMER0_IRQn, (uint32_t)&st_pulse_handler);
  NVIC_EnableIRQ(TIMER0_IRQn);
  NVIC_SetPriority(TIMER3_IRQn, 1); 

  // start in the idle state
  // The stepper interrupt gets started when blocks are being added.
  st_go_idle();
}


// block until all command blocks are executed
void st_synchronize() {
  while(plan_blocks_available()) { 
    //__wfi();  // enter sleep mode until any interrupt triggers
    wait_us(100);
  }
}



// start processing command blocks
void st_wake_up() {
  if (!cycle_start) {
    cycle_start = true;
    // Initialize stepper output bits
    out_bits = (0) ^ (settings.invert_mask);
    // enable stepper pulse interrupt
    LPC_TIM0->TCR = 1;
    led2 = 1;
  }
}


// stop processing command blocks
void st_go_idle() {
  cycle_start = false;
  current_block = NULL;
  // disable stepper pulse interrupt
  LPC_TIM0->TCR = 0;
  set_laser_intensity(LASER_OFF);
  led2 = 0;
}


// This function determines an acceleration velocity change every CYCLES_PER_ACCELERATION_TICK by
// keeping track of the number of elapsed cycles during a de/ac-celeration. The code assumes that
// step_events occur significantly more often than the acceleration velocity iterations.
static bool acceleration_tick() {
  acceleration_tick_counter += cycles_per_step_event;
  if(acceleration_tick_counter > CYCLES_PER_ACCELERATION_TICK) {
    acceleration_tick_counter -= CYCLES_PER_ACCELERATION_TICK;
    return true;
  } else {
    return false;
  }
}



// Timer0 ISR
// The stepper pulse interrupt - This is the workhorse of LasaurGrbl. It is executed at the rate set with
// config_step_timer. It pops blocks from the block_buffer and executes them by pulsing the stepper pins appropriately.
// The bresenham line tracer algorithm controls all three stepper outputs simultaneously.
void st_pulse_handler () {
  if(LPC_TIM0->IR & (0x1<<1)) {  ////////////////////////////// MR1, reset pins
    LPC_TIM0->IR = 0x1<<1;  // needs to be first statement
    
    // reset step pins
    STEPPING_PORT->FIOSET =  settings.invert_mask & STEP_MASK;
    STEPPING_PORT->FIOCLR = ~settings.invert_mask & STEP_MASK;   
  }  ////////////////////////////////////////////////////////////////// END MR1
  
  
  if(LPC_TIM0->IR & (0x1<<0)) {  //////////////////////////////// MR0, set pins
    LPC_TIM0->IR = 0x1<<0;  // needs to be first statement
    
    // set the direction pins
    STEPPING_PORT->FIOSET =  out_bits & DIRECTION_MASK;
    STEPPING_PORT->FIOCLR =  ~out_bits & DIRECTION_MASK;
    
    // set the stepping pins
    STEPPING_PORT->FIOSET =  out_bits & STEP_MASK;
    STEPPING_PORT->FIOCLR =  ~out_bits & STEP_MASK;
    
    step_events_completed++;  // increment step count

    // If there is no current block, attempt to pop one from the buffer
    if (current_block == NULL) {
      // Anything in the buffer?
      current_block = plan_get_current_block();
      // if still no block command, go idle, disable interrupt
      if (current_block == NULL) {
        STEPPING_PORT->FIOSET =  settings.invert_mask & STEP_MASK;
        STEPPING_PORT->FIOCLR = ~settings.invert_mask & STEP_MASK;         
        st_go_idle();
        return;       
      }      
      if (current_block->type == TYPE_LINE) {  // setup new motion block command
        adjusted_rate = current_block->initial_rate;
        acceleration_tick_counter = CYCLES_PER_ACCELERATION_TICK/2; // start halfway, midpoint rule.
        adjust_speed( adjusted_rate ); // initialize cycles_per_step_event
        counter_x = -(current_block->step_event_count >> 1);
        counter_y = counter_x;
        counter_z = counter_x;
        step_events_completed = 0;
      }
    }

    // process current block, populate out_bits (or handle other commands)
    switch (current_block->type) {
      case TYPE_LINE:
        ////// Execute step displacement profile by bresenham line algorithm
        out_bits = current_block->direction_bits;
        counter_x += current_block->steps_x;
        if (counter_x > 0) {
          out_bits |= (1<<X_STEP_BIT);
          counter_x -= current_block->step_event_count;
        }
        counter_y += current_block->steps_y;
        if (counter_y > 0) {
          out_bits |= (1<<Y_STEP_BIT);
          counter_y -= current_block->step_event_count;
        }
        counter_z += current_block->steps_z;
        if (counter_z > 0) {
          out_bits |= (1<<Z_STEP_BIT);
          counter_z -= current_block->step_event_count;
        }
        //////
      
        // apply stepper invert mask
        out_bits ^= settings.invert_mask;

        ////// keep track of absolute position
        if ((out_bits >> X_STEP_BIT) & 1) {
          if ((out_bits >> X_DIRECTION_BIT) & 1 ) {
            st_position[X_AXIS] += 1;
          } else {
            st_position[X_AXIS] -= 1;
          }
        }
        if ((out_bits >> Y_STEP_BIT) & 1) {
          if ((out_bits >> Y_DIRECTION_BIT) & 1 ) {
            st_position[Y_AXIS] += 1;
          } else {
            st_position[Y_AXIS] -= 1;
          }
        }
        if ((out_bits >> Z_STEP_BIT) & 1) {
          if ((out_bits >> Z_DIRECTION_BIT) & 1 ) {
            st_position[Z_AXIS] += 1;
          } else {
            st_position[Z_AXIS] -= 1;
          }
        }
        //////

        ////////// SPEED ADJUSTMENT
        if (step_events_completed < current_block->step_event_count) {  // block not finished
        
          // accelerating
          if (step_events_completed < current_block->accelerate_until) {
            if ( acceleration_tick() ) {  // scheduled speed change
              adjusted_rate += current_block->rate_delta;
              if (adjusted_rate > current_block->nominal_rate) {  // overshot
                adjusted_rate = current_block->nominal_rate;
              }
              adjust_speed( adjusted_rate );
            }
          
          // deceleration start
          } else if (step_events_completed == current_block->decelerate_after) {
              // reset counter, midpoint rule
              // makes sure deceleration is performed the same every time
              acceleration_tick_counter = CYCLES_PER_ACCELERATION_TICK/2;
                   
          // decelerating
          } else if (step_events_completed >= current_block->decelerate_after) {
            if ( acceleration_tick() ) {  // scheduled speed change
              adjusted_rate -= current_block->rate_delta;
              if (adjusted_rate < current_block->final_rate) {  // overshot
                adjusted_rate = current_block->final_rate;
              }
              adjust_speed( adjusted_rate );
            }
          
          // cruising
          } else {
            // No accelerations. Make sure we cruise exactly at the nominal rate.
            if (adjusted_rate != current_block->nominal_rate) {
              adjusted_rate = current_block->nominal_rate;
              adjust_speed( adjusted_rate );
            }
          }
        } else {  // block finished
          current_block = NULL;
          plan_discard_current_block();
        }
        ////////// END OF SPEED ADJUSTMENT
      
        break; 

      case TYPE_AIRGAS_DISABLE:
        airgas_disable();
        current_block = NULL;
        plan_discard_current_block();  
        break;

      case TYPE_AIR_ENABLE:
        air_enable();
        current_block = NULL;
        plan_discard_current_block();  
        break;

      case TYPE_GAS_ENABLE:
        gas_enable();
        current_block = NULL;
        plan_discard_current_block();  
        break;      
    }
  }  ////////////////////////////////////////////////////////////////// END MR0
}



void adjust_speed( uint32_t steps_per_minute ) {
  // usbserial.printf("spm %d\n", steps_per_minute);  //debug
  // We do not step slower than this 
  if (steps_per_minute < MINIMUM_STEPS_PER_MINUTE) { steps_per_minute = MINIMUM_STEPS_PER_MINUTE; }
  
  //cycles_per_step_event = floor((SystemCoreClock/4)/(steps_per_minute/60.0));
  cycles_per_step_event = (SystemCoreClock/4)/(steps_per_minute/60);  // clock_cycles_per_sec/steps_per_sec
  LPC_TIM0->MR0 = cycles_per_step_event;
  
  // set laser intensity proportional to actual speed
  // double actual_speed_mm_per_min =
  //           (current_block->nominal_speed/current_block->nominal_rate)*adjusted_rate;
  //uint8_t slowdown_in_pct_0to255 = (255*adjusted_rate)/current_block->nominal_rate;
  //set_laser_intensity((current_block->nominal_laser_intensity*slowdown_in_pct_0to255)/255);

  // run at constant intensity for now
  set_laser_intensity(current_block->nominal_laser_intensity);
}


void st_go_home() {
  //limits_go_home();
  //plan_set_current_position(0,0,0);
}


void st_get_position( double *x, double *y, double *z) {
  *x = st_position[X_AXIS]/settings.steps_per_mm[X_AXIS];
  *y = st_position[Y_AXIS]/settings.steps_per_mm[Y_AXIS];
  *z = st_position[Z_AXIS]/settings.steps_per_mm[Z_AXIS];
}

double st_get_position_x() {
  return st_position[X_AXIS]/settings.steps_per_mm[X_AXIS];
}
double st_get_position_y() {
  return st_position[Y_AXIS]/settings.steps_per_mm[Y_AXIS];
}
double st_get_position_z() {
  return st_position[Z_AXIS]/settings.steps_per_mm[Z_AXIS];
}



